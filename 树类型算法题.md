# 和树相关的算法题总结
把自己做过的和树相关的算法题都放到一起，总结一下此类问题的解题规律，拿出来经常复习一下。
暂时先不排序，按照剑指offer里的顺序来写吧。

## 1. 重建二叉树
> leetcode《剑指offer》[面试题07](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/).
> 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。
> 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

题目特点：

属于**操作一下根结点，随后依次递归左右子树**以及**建树**的类型。

递归版思路：

建立结点的顺序是根、左、右。<br>
**先序遍历序列以根结点开头，中序遍历序列中根结点左侧结点都属于左子树，右侧结点都属于右子树。<br>
首先找到树的`根结点`，然后通过`中序遍历序列`得到`左子树`和`右子树`的`先序、中序序列`，递归建立二叉树。**<br>

递归版代码：

    public TreeNode buildTree(int[] preorder, int[] inorder) {

        if(preorder.length == 0 || inorder.length == 0)
            return null;

        // 建立树的根结点
        TreeNode root = new TreeNode(preorder[0]);
        int j = 0;
        for(j = 0; j < inorder.length; j++) {
            if(preorder[0] == inorder[j]) {
                break;
            }
        }

        // 此处可以得到左子树和右子树的长度
        int leftLength = j;
        int rightLength = inorder.length-j-1;

        if(leftLength > 0) {
            int[] leftInorder = new int[leftLength];
            System.arraycopy(inorder,0,leftInorder,0,leftLength);

            int[] leftPreorder = new int[leftLength];
            System.arraycopy(preorder,1,leftPreorder,0,j);

            root.left = buildTree(leftPreorder, leftInorder);
        }

        if(rightLength > 0) {
            int[] rightInorder = new int[rightLength];
            System.arraycopy(inorder,j+1,rightInorder,0,rightLength);

            int[] rightPreorder = new int[rightLength];
            System.arraycopy(preorder,j+1,rightPreorder,0,rightLength);

            root.right = buildTree(rightPreorder, rightInorder);
        }
        
        return root;

    }
    
## 2. 树的子结构
> leetcode《剑指offer》[面试题26](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/).
> 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
> B是A的子结构， 即 A中有出现和B相同的结构和节点值。

题目特点：

属于**二叉树的遍历**以及**同步遍历两棵二叉树**的类型。

递归版思路：

从根结点开始遍历，共分两个步骤：<br>
 （1）找到A中和B根结点值一致的结点；<br>
 （2）同时向下遍历两棵树，判断是否结构相同。<br>
递推步骤：<br>
判断根结点val是否相同，随后依次递归左子树、右子树。

递归版代码：

    public boolean isSubStructure(TreeNode A, TreeNode B) {
        
        // 注意这个条件，当B本身就为一棵空树时，是不算A的子结构的
        // 这样的情况在面试过程中一定要问清楚，开始动手写之前要确定所有细节问题
        if (A == null || B == null){
            return false;
        }

        boolean res = false;
        // 根结点
        if (A.val == B.val) {
            res = hasSub(A, B);   // 只有在找到相同的根结点时才进行比较
        }
        // 左子树
        if (!res) {
            res = isSubStructure(A.left, B);  // 这属于遍历过程
        }
        // 右子树
        if (!res) {
            res = isSubStructure(A.right, B); // 这属于遍历过程
        }

        return res;
    }

    boolean hasSub(TreeNode A, TreeNode B) {
        if (B == null)
            return true;
        if (A == null)
            return false;

        return (A.val == B.val) &&
                hasSub(A.left, B.left) &&
                hasSub(A.right, B.right);
    }





