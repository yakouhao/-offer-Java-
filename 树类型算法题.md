# 和树相关的算法题总结
把自己做过的和树相关的算法题都放到一起，总结一下此类问题的解题规律，拿出来经常复习一下。
暂时先不排序，按照剑指offer里的顺序来写吧。

## 1. 重建二叉树
> leetcode《剑指offer》[面试题07](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/).

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

    class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {

        if(preorder.length == 0 || inorder.length == 0)
            return null;

        // 建立树的根结点
        TreeNode root = new TreeNode(preorder[0]);
        int j = 0;
        for(j = 0; j < inorder.length; j++) {
            if(preorder[0] == inorder[j]) {
                break;
            }
        }

        // 此处可以得到左子树和右子树的长度
        int leftLength = j;
        int rightLength = inorder.length-j-1;

        if(leftLength > 0) {
            int[] leftInorder = new int[leftLength];
            System.arraycopy(inorder,0,leftInorder,0,leftLength);

            int[] leftPreorder = new int[leftLength];
            System.arraycopy(preorder,1,leftPreorder,0,j);

            root.left = buildTree(leftPreorder, leftInorder);
        }

        if(rightLength > 0) {
            int[] rightInorder = new int[rightLength];
            System.arraycopy(inorder,j+1,rightInorder,0,rightLength);

            int[] rightPreorder = new int[rightLength];
            System.arraycopy(preorder,j+1,rightPreorder,0,rightLength);

            root.right = buildTree(rightPreorder, rightInorder);
        }
        
        return root;

    }
    }




